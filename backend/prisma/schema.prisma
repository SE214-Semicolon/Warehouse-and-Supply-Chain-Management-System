generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model RefreshToken {
  id        String    @id @default(uuid()) @db.Uuid
  userId    String    @db.Uuid
  userEmail String
  userRole  UserRole
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?
  user      User      @relation(fields: [userId], references: [id])
}

model UserInvite {
  id          String    @id @default(uuid()) @db.Uuid
  email       String    @db.VarChar(255)
  role        UserRole
  token       String    @unique @db.VarChar(100)
  createdById String?   @db.Uuid
  createdAt   DateTime  @default(now())
  expiresAt   DateTime
  usedAt      DateTime?
  usedById    String?   @db.Uuid

  createdBy User? @relation("InviteCreatedBy", fields: [createdById], references: [id])
  usedBy    User? @relation("InviteUsedBy", fields: [usedById], references: [id])

  @@index([email], name: "idx_invite_email")
  @@index([token], name: "idx_invite_token")
  @@index([expiresAt], name: "idx_invite_expires")
}

/// *
///  * MODELS
model Warehouse {
  id        String     @id @default(uuid()) @db.Uuid
  code      String     @unique @db.VarChar(50)
  name      String     @db.VarChar(200)
  address   String?
  metadata  Json?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  locations Location[]
  shipments Shipment[]
}

model Location {
  id              String           @id @default(uuid()) @db.Uuid
  warehouseId     String           @db.Uuid
  code            String           @db.VarChar(100)
  name            String?          @db.VarChar(200)
  capacity        Int?
  type            String?          @db.VarChar(50)
  properties      Json?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  inventory       Inventory[]
  warehouse       Warehouse        @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  stockMovesFrom  StockMovement[]  @relation("FromLoc")
  stockMovesTo    StockMovement[]  @relation("ToLoc")
  salesOrderItems SalesOrderItem[]

  @@unique([warehouseId, code])
  @@index([warehouseId], map: "idx_location_warehouse")
}

model ProductCategory {
  id       String            @id @default(uuid()) @db.Uuid
  name     String            @unique @db.VarChar(200)
  parentId String?           @db.Uuid
  metadata Json?
  products Product[]
  parent   ProductCategory?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children ProductCategory[] @relation("CategoryHierarchy")
}

model Product {
  id         String   @id @default(uuid()) @db.Uuid
  sku        String   @unique @db.VarChar(100)
  name       String   @db.VarChar(300)
  categoryId String?  @db.Uuid
  unit       String   @db.VarChar(50)
  barcode    String?  @db.VarChar(200)
  parameters Json?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Fields for alerts and demand planning
  minStockLevel    Int? // Minimum stock level before an alert is triggered
  reorderPoint     Int? // Stock level at which a new order should be placed
  leadTimeDays     Int? // Expected number of days for a purchase order to arrive
  safetyStockLevel Int? // Extra quantity of an item held in inventory

  category        ProductCategory?    @relation(fields: [categoryId], references: [id])
  batches         ProductBatch[]
  stockMoves      StockMovement[]
  poItems         PurchaseOrderItem[]
  soItems         SalesOrderItem[]
  shipmentItems   ShipmentItem[]
  demandForecasts DemandForecast[]

  @@index([sku], name: "idx_product_sku")
}

model ProductBatch {
  id               String    @id @default(uuid()) @db.Uuid
  productId        String    @db.Uuid
  batchNo          String?
  quantity         Int       @default(0)
  manufactureDate  DateTime?
  expiryDate       DateTime?
  barcodeOrQr      String?
  inboundReceiptId String?   @db.Uuid
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  product       Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  inventory     Inventory[]
  stockMoves    StockMovement[]
  poItems       PurchaseOrderItem[]
  soItems       SalesOrderItem[]
  shipmentItems ShipmentItem[]

  @@unique([productId, batchNo])
  @@index([productId], name: "idx_productbatch_product")
}

model Inventory {
  id             String    @id @default(uuid()) @db.Uuid
  productBatchId String    @db.Uuid
  locationId     String    @db.Uuid
  availableQty   Int       @default(0)
  reservedQty    Int       @default(0)
  updatedAt      DateTime  @updatedAt
  deletedAt      DateTime?

  productBatch ProductBatch @relation(fields: [productBatchId], references: [id], onDelete: Cascade)
  location     Location     @relation(fields: [locationId], references: [id], onDelete: Cascade)

  @@unique([productBatchId, locationId])
  @@index([locationId], name: "idx_inventory_location")
  @@index([productBatchId], name: "idx_inventory_product")
  @@index([deletedAt], name: "idx_inventory_deleted_at")
}

model StockMovement {
  id             String            @id @default(uuid()) @db.Uuid
  movementType   StockMovementType
  productBatchId String?           @db.Uuid
  productId      String?           @db.Uuid
  fromLocationId String?           @db.Uuid
  toLocationId   String?           @db.Uuid
  quantity       Int
  reference      String?
  note           String?
  createdById    String?           @db.Uuid
  createdAt      DateTime          @default(now())
  idempotencyKey String?           @unique
  createdBy      User?             @relation("UserStockMovements", fields: [createdById], references: [id])
  fromLocation   Location?         @relation("FromLoc", fields: [fromLocationId], references: [id])
  productBatch   ProductBatch?     @relation(fields: [productBatchId], references: [id])
  product        Product?          @relation(fields: [productId], references: [id])
  toLocation     Location?         @relation("ToLoc", fields: [toLocationId], references: [id])
}

model Supplier {
  id             String          @id @default(uuid()) @db.Uuid
  code           String?         @unique @db.VarChar(100)
  name           String          @db.VarChar(300)
  contactInfo    Json?
  address        String?
  createdAt      DateTime        @default(now())
  deletedAt      DateTime?
  purchaseOrders PurchaseOrder[]
}

model Customer {
  id          String       @id @default(uuid()) @db.Uuid
  code        String?      @unique @db.VarChar(100)
  name        String       @db.VarChar(300)
  contactInfo Json?
  address     String?
  createdAt   DateTime     @default(now())
  salesOrders SalesOrder[]
}

model PurchaseOrder {
  id              String              @id @default(uuid()) @db.Uuid
  poNo            String              @unique @db.VarChar(100)
  supplierId      String?             @db.Uuid
  status          PoStatus            @default(draft)
  placedAt        DateTime?
  expectedArrival DateTime?
  totalAmount     Decimal?            @db.Decimal(15, 2)
  notes           String?
  createdById     String?             @db.Uuid
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  createdBy       User?               @relation("UserCreatedPO", fields: [createdById], references: [id])
  supplier        Supplier?           @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  items           PurchaseOrderItem[]

  @@index([status], map: "idx_po_status")
  @@index([supplierId], map: "idx_po_supplier")
  @@index([placedAt], map: "idx_po_placed_at")
}

model PurchaseOrderItem {
  id              String        @id @default(uuid()) @db.Uuid
  purchaseOrderId String        @db.Uuid
  productId       String        @db.Uuid
  productBatchId  String?       @db.Uuid
  qtyOrdered      Int
  qtyReceived     Int           @default(0)
  unitPrice       Decimal?      @db.Decimal(12, 2)
  lineTotal       Decimal?      @db.Decimal(15, 2)
  remark          String?
  productBatch    ProductBatch? @relation(fields: [productBatchId], references: [id])
  product         Product       @relation(fields: [productId], references: [id])
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
}

model SalesOrder {
  id           String           @id @default(uuid()) @db.Uuid
  soNo         String           @unique @db.VarChar(100)
  customerId   String?          @db.Uuid
  status       OrderStatus      @default(pending)
  placedAt     DateTime?
  totalAmount  Decimal?         @db.Decimal(15, 2)
  createdById  String?          @db.Uuid
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  createdBy    User?            @relation("UserCreatedSO", fields: [createdById], references: [id])
  customer     Customer?        @relation(fields: [customerId], references: [id])
  items        SalesOrderItem[]
  ShipmentItem ShipmentItem[]
  shipments    Shipment[]

  @@index([status], map: "idx_so_status")
}

model SalesOrderItem {
  id             String        @id @default(uuid()) @db.Uuid
  salesOrderId   String        @db.Uuid
  productId      String        @db.Uuid
  productBatchId String?       @db.Uuid
  locationId     String?       @db.Uuid
  qty            Int
  qtyFulfilled   Int           @default(0)
  unitPrice      Decimal?      @db.Decimal(12, 2)
  lineTotal      Decimal?      @db.Decimal(15, 2)
  productBatch   ProductBatch? @relation(fields: [productBatchId], references: [id])
  product        Product       @relation(fields: [productId], references: [id])
  salesOrder     SalesOrder    @relation(fields: [salesOrderId], references: [id], onDelete: Cascade)
  location       Location?     @relation(fields: [locationId], references: [id])
}

model Shipment {
  id                String                  @id @default(uuid()) @db.Uuid
  shipmentNo        String?                 @unique @db.VarChar(120)
  warehouseId       String                  @db.Uuid
  salesOrderId      String                  @db.Uuid
  carrier           String?
  trackingCode      String?
  status            ShipmentStatus          @default(preparing)
  shippedAt         DateTime?
  deliveredAt       DateTime?
  estimatedDelivery DateTime?
  notes             String?
  warehouse         Warehouse               @relation(fields: [warehouseId], references: [id], onDelete: Restrict)
  salesOrder        SalesOrder              @relation(fields: [salesOrderId], references: [id], onDelete: Restrict)
  items             ShipmentItem[]
  trackingEvents    ShipmentTrackingEvent[]

  @@index([warehouseId], name: "idx_shipment_warehouse")
  @@index([salesOrderId], name: "idx_shipment_sales_order")
}

model ShipmentItem {
  id             String        @id @default(uuid()) @db.Uuid
  shipmentId     String        @db.Uuid
  salesOrderId   String?       @db.Uuid
  productId      String?       @db.Uuid
  productBatchId String?       @db.Uuid
  qty            Int
  productBatch   ProductBatch? @relation(fields: [productBatchId], references: [id])
  product        Product?      @relation(fields: [productId], references: [id])
  salesOrder     SalesOrder?   @relation(fields: [salesOrderId], references: [id])
  shipment       Shipment      @relation(fields: [shipmentId], references: [id], onDelete: Cascade)
}

model ShipmentTrackingEvent {
  id         String   @id @default(uuid()) @db.Uuid
  shipmentId String   @db.Uuid
  eventTime  DateTime @default(now())
  location   String?
  statusText String?
  rawPayload Json?

  shipment Shipment @relation(fields: [shipmentId], references: [id], onDelete: Cascade)
}

model DemandForecast {
  id                 String   @id @default(cuid())
  productId          String   @db.Uuid
  product            Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  forecastDate       DateTime // The date for which the forecast is made
  forecastedQuantity Int // The forecasted sales quantity
  algorithmUsed      String   @default("SIMPLE_MOVING_AVERAGE") // The algorithm used for this forecast
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@unique([productId, forecastDate])
  @@index([productId], name: "idx_demandforecast_product")
}

model User {
  id             String          @id @default(uuid()) @db.Uuid
  username       String          @unique @db.VarChar(150)
  fullName       String?
  passwordHash   String?
  email          String?         @unique
  role           UserRole        @default(warehouse_staff)
  active         Boolean         @default(true)
  metadata       Json?
  createdAt      DateTime        @default(now())
  purchaseOrders PurchaseOrder[] @relation("UserCreatedPO")
  refreshTokens  RefreshToken[]
  salesOrders    SalesOrder[]    @relation("UserCreatedSO")
  stockMovements StockMovement[] @relation("UserStockMovements")
  invitesCreated UserInvite[]    @relation("InviteCreatedBy")
  invitesUsed    UserInvite[]    @relation("InviteUsedBy")
}

// AuditLog moved to MongoDB collection 'audit_logs' (see MongoDBService)
// Alert moved to MongoDB collection 'alerts' (see MongoDBService)

/// *
///  * ENUMS
enum OrderStatus {
  pending
  approved
  processing
  shipped
  closed
  cancelled
}

enum PoStatus {
  draft
  ordered
  received
  partial
  cancelled
}

enum StockMovementType {
  purchase_receipt
  sale_issue
  adjustment
  transfer_in
  transfer_out
  returned
  reservation
  release
  consumption
}

enum ShipmentStatus {
  preparing
  in_transit
  delivered
  delayed
  cancelled
}

enum UserRole {
  admin
  manager
  warehouse_staff
  procurement
  sales
  logistics
  analyst
  partner
}
